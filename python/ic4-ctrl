#!/usr/bin/env python3

# import filepath
import time
import threading
import os
from enum import Enum
import sys

import textwrap
import argparse
import ic4 as ic4

# constants for output formatting
BOLD = '\033[1m'
END = '\033[0m'


class ImageType(Enum):
    """
    Helper enum for easier argparse generation.
    Contains supported image types.
    """
    BMP = "bmp"
    JPEG = "jpeg"
    PNG = "png"
    TIFF = "tiff"

    def __str__(self):
        return self.value


class VideoType(Enum):
    """
    Helper enum for easier argparse generation.
    Contains supported image types.
    """
    H264 = "h264"
    H265 = "h265"

    def __str__(self):
        return self.value


def list_devices():
    """
    List available devices
    """
    devs = ic4.DevEnum()

    dev_list = devs.device_list()

    # l = sorted(l, key=DevInfo.serial())

    if dev_list.count:
        print("Model\t\tSerial\t\tIdentifier")

    for d in dev_list:

        print(f"{d.model_name}\t\t{d.serial}\t\t{d.unique_name}")
        print(f"{d.unique_name}")


def list_properties(dev: ic4.DevInfo):
    """
    List properties of device
    """

    grabber = ic4.Grabber()
    grabber.device_open(dev)

    for p in grabber.device_property_map.all:

        print(f"{BOLD}{p.name:<16}{END} - {p.type} - {p.visibility}")
        print(textwrap.fill(f"{p.description}", 80,
                            initial_indent="\t",
                            subsequent_indent="\t"))
        print("")
        print(f"\tAvailable: {p.is_available} Locked: {p.is_locked} Readonly: {p.is_readonly}")
        print(f"\tAffects others: {p.is_selector}")
        # if p.is_selector:
        victims = p.selected_properties
        if victims:
            for v in victims:
                print(f"\t\t{v.name}")
            print()

        if p.type == ic4.PropertyType.COMMAND:
            print("")
            continue
        elif p.type == ic4.PropertyType.BOOLEAN:
            if p.has_default:
                print(f"\tDefault: {p.default}")
        elif p.type == ic4.PropertyType.INTEGER:
            print(f"\tRepresentation: {p.representation}")
            print(f"\t{p.minimum} - {p.maximum} - {p.increment}")
        elif p.type == ic4.PropertyType.FLOAT:

            print(f"\tRepresentation: {p.representation}")
            print(f"\t{p.minimum} - {p.maximum} - {p.increment}")

        elif p.type == ic4.PropertyType.ENUMERATION:

            e = p.entries
            print("\tAvailable entries:")
            for entry in e:
                print(f"\t{entry.value} - {entry.name}")
        elif p.type == ic4.PropertyType.STRING:
            pass
        try:
            value = p.value
        except ic4.IC4Exception as e:
            value = "==Unknown=="
            if e.code == ic4.Error.GenICamChunkdataNotConnected:
                print("Requires ChunkData to be connected")
        except AttributeError as e:
            print(f"{p.name} {e}")
            continue
        print("")
        print(f"\tValue: {value}")

        print("")  # empty line just for readability


def set_properties(dev: ic4.DevInfo, new_props: list):
    """"""

    grabber = ic4.Grabber()
    grabber.device_open(dev)

    props = grabber.device_property_map

    for p in new_props:

        name, value = p.split("=")

        prop = props.get(name)
        if prop:
            if prop.type == ic4.PropertyType.BOOLEAN:
                props.set_boolean_value(name, value)
            if prop.type == ic4.PropertyType.COMMAND:
                props.execute_command(name)
            if prop.type == ic4.PropertyType.INTEGER:
                props.set_integer_value(name, value)
            if prop.type == ic4.PropertyType.FLOAT:
                props.set_float_value(name, value)
            if prop.type == ic4.PropertyType.ENUMERATION:
                pass
            if prop.type == ic4.PropertyType.STRING:
                props.set_string_value(name, value)
        print(name, value)


def save_video(dev: ic4.DevInfo,
               store_dir=os.getcwd(),
               file_name: str = "video",
               video_type: VideoType = VideoType.H264):
    """
    Save video to file.

    Args:
        dev: Device that shall be opened
        store_dir: Default: current working dir
        file_name: Default: "video"
        video_type: Default: h264
    """
    grabber = ic4.Grabber()
    grabber.device_open(dev)

    fps = grabber.device_property_map.get_float("AcquisitionFrameRate")

    writer = ic4.VideoWriter(ic4.VideoWriterType.MP4_H264)

    class Listener(ic4.QueueSinkListener):

        def __init__(self):
            pass

        def sink_connected(self, sink: ic4.QueueSink, frame_type: ic4.FrameType) -> bool:
            sink.alloc_and_queue_buffers(5)
            writer.begin_file("/tmp/test.mp4", frame_type, fps)
            return True

        def sink_disconnected(self, sink: ic4.QueueSink):
            writer.finish_file()

        def frames_queued(self, sink: ic4.QueueSink):
            while True:
                try:
                    f = sink.pop_output_buffer()
                    writer.add_frame(f)
                except ic4.IC4Exception:
                    return

    listen = Listener()
    sink = ic4.QueueSink(listen)

    grabber.stream_setup(sink)

    time.sleep(10)


def save_image(dev: ic4.DevInfo,
               n_images,
               store_dir=os.getcwd(),
               file_name: str = "image-{C}",
               file_type: ImageType = ImageType.BMP):
    """
    Save video to file.

    Args:
        dev: Device that shall be opened
        store_dir: Default: current working dir
        file_name: Default: "video"
        video_type: Default: bmp
    """
    grabber = ic4.Grabber()
    grabber.device_open(dev)

    sink = ic4.SnapSink()

    grabber.stream_setup(sink)

    def save(f: ic4.Frame, f_name: str):

        # error via exception
        if file_type == ImageType.BMP:
            f.save_as_bmp(f"{store_dir}/{f_name}.{file_type}")
        elif file_type == ImageType.JPEG:
            f.save_as_jpeg(f"{store_dir}/{f_name}.{file_type}")
        if file_type == ImageType.PNG:
            f.save_as_png(f"{store_dir}/{f_name}.{file_type}")
        if file_type == ImageType.TIFF:
            f.save_as_tiff(f"{store_dir}/{f_name}.{file_type}")

    images = sink.snap_sequence(n_images, 1000)
    for n in range(0, n_images):
        f_name = file_name.replace("{C}", str(n))
        save(images[n], f_name)


def get_device(serial: str) -> ic4.DevInfo:
    """
    Retrieve DevInfo for serial.

    Return None if not found.
    """
    dev_list = ic4.DevEnum.device_list()

    for d in dev_list:
        print(d.serial)
        if d.serial == serial:
            return d
    return None


def live_stream(dev: ic4.DevInfo):
    """
    Start a live stream.

    This will open a display window.
    """
    grabber = ic4.Grabber()
    grabber.device_open(dev)

    # required to have format compatible with display
    # autoconversion ot yet available
    grabber.device_property_map.set_enumeration_entry("PixelFormat", "BGRa8")

    display = ic4.FloatingDisplay()

    grabber.stream_setup(None, display)

    e = threading.Event()

    def window_closed(disp: ic4.Display):
        print("window closed called")
        e.set()

    cb_token = display.event_register_window_closed(window_closed)
    t = None
    try:
        e.wait(timeout=t)
    except KeyboardInterrupt:
        pass

    display.event_remove_window_closed(cb_token)


def main() -> int:

    arguments = argparse.ArgumentParser()

    subs = arguments.add_subparsers(dest='command')
    subs.add_parser("list", help="List devices")

    # args for listing/saving properties

    props = subs.add_parser("properties", help="List properties of device")

    props.add_argument("--json", "-j", help="Print properties serialized",
                       action="store_true")

    props.add_argument("--serial", "-s", help="Serial of the camera",
                       required=True)
    # args for setting properties

    setter = subs.add_parser("set", help="Set properties of device")

    setter.add_argument("--properties", "-p", nargs="+", required=True, help="List of properties to be set. (e.g. -p a=1 b=2)")

    setter.add_argument("--serial", "-s", help="Serial of the camera",
                        required=True)

    # args for saving images

    image = subs.add_parser("image", help="Save image from device")
    image.add_argument("--count", "-c", help="Number of images to save. Default=1",
                       default=1, action="store")
    image.add_argument("--path", help="Directory in which to save images. Default=<current dir>",
                       default=os.getcwd())
    image.add_argument("--name", help="Filename of saved images",
                       default="image-{C}")
    image.add_argument("--type", help="Image types",
                       type=ImageType, choices=list(ImageType), default=ImageType.BMP)

    image.add_argument("--serial", "-s", help="Serial of the camera",
                       required=True)

    # args for saving video

    video = subs.add_parser("video", help="Save video from device")
    video.add_argument("--time", "-t", help="Time period that shall be saved in seconds. Default=10s",
                       default=10, action="store")
    video.add_argument("--path", help="Directory in which to save videos. Default=<current dir>",
                       default=os.getcwd())
    video.add_argument("--name", help="Filename of saved videos",
                       default="video")
    video.add_argument("--type", help="Video types",
                       type=VideoType, choices=list(VideoType), default=VideoType.H264)

    video.add_argument("--serial", "-s", help="Serial of the camera",
                       required=True)

    # args for live stream

    stream = subs.add_parser("live", help="Display live stream.")

    stream.add_argument("--serial", "-s", help="Serial of the camera",
                        required=True)

    args = arguments.parse_args()

    ic4.Library.init()

    if args.command == "list":
        list_devices()
        return 0

    d = get_device(args.serial)
    if not d:
        print("Unable to find device with given serial!")
        return 1

    if args.command == "properties":
        if args.serialize:
            g = ic4.Grabber()
            g.device_open(d)
            # p = filepath.Path('state.json')
            # g.save_device_state_to_file(p)
            g.save_device_state_to_file('state.json')
            props = g.device_property_map
            print(props.serialize().decode("utf-8"))
        else:
            list_properties(d)
    elif args.command == "set":
        set_properties(d, args.properties)
    elif args.command == "image":
        save_image(d, args.count,
                   args.path, args.name,
                   args.type)
    elif args.command == "video":
        save_video(d,
                   args.time,
                   args.path, args.name,
                   args.type)
    elif args.command == "live":
        live_stream(d)
    else:
        arguments.print_help()

    return 0


if __name__ == "__main__":
    sys.exit(main())
